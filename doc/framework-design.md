## 架构设计

### 1. 常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的

> CDN 缓存，redis 缓存，ehcache 缓存等
> CDN 图片资源 js 等，redis一主一从 echcache缓存数据

### 2. 用 java 自己实现一个 LRU。

> ```java
> final int cacheSize = 100;
> Map<String, String> map = new LinkedHashMap<String, String>(
>     (int) Math.ceil(cacheSize / 0.75f) + 1, 0.75f, true) {
> 	@Override
> 	protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
> 		return size() > cacheSize;
> 	}
> }
> ```
>
> [LRU缓存实现(Java)](https://www.cnblogs.com/lzrabbit/p/3734850.html)

### 3. 分布式集群下如何做到唯一序列号

> * Redis 生成
> * mongodb 的 objectId
> * zookeeper生成
>
> [分布式系统唯一ID生成方案汇总](https://www.cnblogs.com/haoxinyue/p/5208136.html)

### 4. 设计一个秒杀系统，30 分钟没付款就自动关闭交易。

> * 分流
> * 限流
> * 异步–公平性（只能参加一次）
> * 用户体验（第几位，多少分钟，一抢完）
> * 容错处理
> * Redis 队列 mysql
> * 30分钟关闭：可以借助redis的发布订阅机制 在失效时进行后续操作，其他mq也可以
>
> [1 号店 11.11：秒杀排队系统设计理念](https://www.infoq.cn/article/yhd-11-11-queuing-system-design/)

### 5. 如何使用 redis 和 zookeeper 实现分布式锁？有什么区别优缺点，分别适用什么场景。

> 首先分布式锁实现常见的有 **数据库锁(表记录)**、**zookeeper**、**基于 zookeeper（临时有序节点可以实现的）**的三种
>
> **Redis**
>
> Redis 适用于对性能要求特别高的场景。Redis 可以每秒执行10w次，内网延迟不超过1ms。缺点是数据存放于内存，宕机后锁丢失。
>
> **锁无法释放？**
>
> 使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。
>
> **非阻塞锁？**
>
> 使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。
>
> **不可重入？**
>
> 使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。
>
> **单点问题？**
>
> 使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。
>
> [分布式锁的几种实现方式](http://www.hollischuang.com/archives/1716)

### 6. 如果有人恶意创建非法连接，怎么解决。

> 可以使用filter过滤处理

### 7. 分布式事务的原理，优缺点，如何使用分布式事务。

> Two Phase commit 协议
>
> 优点是可以管理多机事务，拥有无线扩展性 确定是易用性难，承担延时风险
>
> JTA，atomiks等
>
> [阿里沈询：分布式数据库原理与实践（三）](https://yq.aliyun.com/live/185)

### 8. 什么是一致性 hash

> 一致性hash是一种分布式hash实现算法。满足**平衡性**、**单调性**、**分散性**、和**负载**。
>
> [每天进步一点点——五分钟理解一致性哈希算法(consistent hashing)](https://blog.csdn.net/cywosp/article/details/23397179/)

### 9. 什么是 restful，讲讲你理解的 restful。
> REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。
> [RESTful](https://baike.baidu.com/item/RESTful/4406165)

### 10. 如何设计建立和保持 100w 的长连接。

> 服务器内核调优(TCP，文件数)，客户端调优，框架选择(netty)

### 11. 如何防止缓存雪崩

> 缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。
>
> **解决思路：**
>
> 1. 采用加锁计数，或者使用合理的队列数量来避免缓存失效时对数据库造成太大的压力。这种办法虽然能缓解数据库的压力，但是同时又降低了系统的吞吐量。
> 2. 分析用户行为，尽量让失效时间点均匀分布。避免缓存雪崩的出现。
> 3. 如果是因为某台缓存服务器宕机，可以考虑做主备，比如：redis主备，但是双缓存涉及到更新事务的问题，update可能读到脏数据，需要好好解决。
>
> [缓存雪崩，缓存穿透解决方案]https://www.cnblogs.com/jinjiangongzuoshi/archive/2016/03/03/5240280.html()

### 12. 解释什么是 MESI 协议(缓存一致性)

> MESI是四种缓存段状态的首字母缩写，任何多核系统中的缓存段都处于这四种状态之一。我将以相反的顺序逐个讲解，因为这个顺序更合理：
>
> * 失效（Invalid）缓存段，要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。
> * 共享（Shared）缓存段，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。
> * 独占（Exclusive）缓存段，和S状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态。
> * 已修改（Modified）缓存段，属于脏段，它们已经被所属的处理器修改了。如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中——这和回写模式下常规的脏段处理方式一样。

### 13. 说说你知道的几种 HASH 算法，简单的也可以。

> 哈希(Hash)算法,即散列函数。 它是一种单向密码体制，即它是一个从明文到密文的不可逆的映射，只有加密过程,没有解密过程。 同时，哈希函数可以将任意长度的输入经过变化以后得到固定长度的输出
>
> * MD4
> * MD5 
> * SHA

### 14. 什么是 paxos 算法。

> **Paxos 算法 **是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的"La"，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。
>
> [Paxos 算法]https://baike.baidu.com/item/Paxos%20%E7%AE%97%E6%B3%95()

### 15. 什么是 ZAB 协议。

> ZAB 是 Zookeeper 原子广播协议的简称
> 整个ZAB协议主要包括消息广播和崩溃恢复两个过程，进一步可以分为三个阶段，分别是：
>
> * 发现（Discovery）
> * 同步（Synchronization）
> * 广播（Broadcast）
>
> 组成ZAB协议的每一个分布式进程，都会循环执行这三个阶段，将这样一个循环称为一个主进程周期。
>
> [【一致性协议04】 ZAB协议概述](https://zzzvvvxxxd.github.io/2016/08/09/ZAB/)

### 16. 一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。

> * 点击编辑的时候，利用redis进行加锁setNX完了之后 expire 一下
> * 也可以用版本号进行控制

### 17. 线上系统突然变得异常缓慢，你如何查找问题。

> * 逐级排查（网络，磁盘，内存，cpu）
>
> * 数据库
> * 日志
> * 中间件等也可通过监控工具排查。

### 18. 说说你平时用到的设计模式

> **单例、代理、模板、策略、命令**
>
> * 单例模式：单例模式核心只需要new一个实例对象的模式，比如数据库连接，在线人数等，一些网站上看到的在线人数统计就是通过单例模式实现的，把一个计时器存放在数据库或者内存中，当有人登陆的时候取出来加一再放回去，有人退出登陆的时候取出来减一再放回去，但是当有两个人同时登陆的时候，会同时取出计数器，同时加一，同时放回去，这样的话数据就会错误，所以需要一个全局变量的对象给全部人使用，只需要new出一个实例对象，这就是单例模式的应用，并且单例模式节省资源，因为它控制了实例对象的个数，并有利于gc回收。
> * 策略模式：就是将几个类中公共的方法提取到一个新的类中，从而使扩展更容易，保证代码的可移植性，可维护性强。比如有个需求是写鸭子对象，鸭子有叫，飞，外形这三种方法，如果每个鸭子类都写这三个方法会出现代码的冗余，这时候我们可以把鸭子中的叫，飞，外形这三个方法提取出来，放到鸭父类中，让每个鸭子都继承这个鸭父类，重写这三个方法，这样封装的代码可移植性强，当用户提出新的需求比如鸭子会游泳，那么对于我们oo程序员来讲就非常简单了我们只需要在鸭父类中加一个游泳的方法，让会游泳的鸭子重写游泳方法就可以了。
> * 工厂模式：简单的工厂模式主要是统一提供实例对象的引用，通过工厂模式接口获取实例对象的引用。比如一个登陆功能，后端有三个类，controller类，interface类，实现接口的实现类。当客户端发出一个请求，当请求传到controller类中时，controller获取接口的引用对象，而实现接口的实现类中封装好了登陆的业务逻辑代码。当你需要加一个注册需求的时候只需要在接口类中加一个注册方法，实现类中实现方法，controller获取接口的引用对象即可，不需要改动原来的代码，这种做法是的可拓展性强。
>
> [14种常用设计模式](https://www.jianshu.com/p/bdf65e4afbb0)

### 19. Dubbo 的原理，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现。重试转发，快速失败的策略是怎样的。

> Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。
>
> Cluster 实现集群
>
> 在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随机调用。
>
> **策略**
>
> * Random LoadBalance：随机，按权重比率设置随机概率。
> * RoundRobin LoadBalance：轮循，按公约后的权重比率设置轮循比率。
> * LeastActive LoadBalance：最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。
> * ConsistentHash LoadBalance：一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。
> * 快速失败：只发起一次调用，失败立即报错。
>
> [分布式框架dubbo原理解析](https://my.oschina.net/u/1378920/blog/693374)

### 20. 一次 RPC 请求的流程是什么

> 1. 服务消费方（client）调用以本地调用方式调用服务；
> 2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
> 3. client stub找到服务地址，并将消息发送到服务端；
> 4. server stub收到消息后进行解码；
> 5. server stub根据解码结果调用本地的服务；
> 6. 本地服务执行并将结果返回给server stub；
> 7. server stub将返回结果打包成消息并发送至消费方；
> 8. client stub接收到消息，并进行解码；
> 9. 服务消费方得到最终结果。

### 21. 异步模式的用途和意义。

> 异步模式使用与服务器多核，并发严重的场景。
> 可提高服务吞吐量大，不容易受到冲击，可以采用并发策略，提高响应时间
> 缓存数据过期后的更新如何设计。
>
> * **失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
> * **命中**：应用程序从cache中取数据，取到后返回。
> * **更新**：先把数据存到数据库中，成功后，再让缓存失效。

### 22. 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。

> * **开闭原则（Open Close Principle）**
>   一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
>* **里氏代换原则（Liskov Substitution Principle）**
>   子类型必须能够替换掉它们的父类型。
> * **依赖倒转原则（Dependence Inversion Principle）**
>  高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程
> * **接口隔离原则（Interface Segregation Principle）**
>   建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少
>* **组合/聚合复用原则**
>   说要尽量的使用合成和聚合，而不是继承关系达到复用的目的
> * **迪米特法则（Law Of Demeter）**
>  迪米特法则其根本思想，是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。
> * **单一职责原则（Single Responsibility Principle）**
>   一个类只负责一项职责，应该仅有一个引起它变化的原因

### 23. 设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。

> MVC 模式，即常见的 MVC 框架。
> SSM SSH SSI等

### 24. 曾经参与设计的服务器架构。



### 25. 应用服务器怎么监控性能，各种方式的区别。



### 26. 如何设计一套高并发支付方案，架构如何设计。



### 27. 如何实现负载均衡，有哪些算法可以实现。



### 28. Zookeeper 的用途，选举的原理是什么。



### 29. Mybatis 的底层实现原理。



### 30. 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。

### 31. 请思考一个方案，实现分布式环境下的 countDownLatch。



### 32. 后台系统怎么防止请求重复提交。

> 可以通过token值进行防止重复提交，存放到redis中，在表单初始化的时候隐藏在表单中，添加的时候在移除。判断这个状态即可防止重复提交。

### 33. 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。本地缓存在并发使用时的注意事项。

### 34. 描述一个服务从发布到被消费的详细过程。



### 35. 讲讲你理解的服务治理。



### 36. 如何做到接口的幂等性。

