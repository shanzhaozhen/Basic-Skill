## JVM

### 1. Java内存

> 
>
> ```mermaid
> graph LR
> A[Java内存] --> B[私有内存区]
> A --> C[共享内存区]
> B --> D[虚拟机]
> B --> E[程序计数器]
> B --> F[本地方法栈]
> C --> G[Java堆]
> C --> H[方法区]
> H --> I[非堆内存&#40永久&#41]
> ```
>
> * **私有内存区**：伴随线程的产生而产生，一旦线程终止，私有内存区也会自动消除
> * **程序计数器**：指示当前程序执行到了哪一行，执行Java方法时记录正在执行的虚拟机字节码指令地址；执行本地方法时，计数器值为null
> * **虚拟机栈**：用于执行Java方法，栈帧存储局部变量表，操作数栈，动态链接，方法返回地址和一些额外的符加信息。程序执行时入栈；执行完成后栈帧出栈。
> * **Java堆**：Java虚拟机管理的内存中最大的一块，所有线程共享，几乎所有的对象实例和数组都在这里分配内存。GC主要就是在Java堆中进行的。 堆内存又分为：新生代（新生代又分为Eden80%，Survivor20%）和老年代（Old），并且一般新生代的空间比老年代大。
> * **方法区**：只有一个方法区共享。实际也是堆,只是用于存储类,常量相关的信息，来存放程序中永远不变或唯一的内容(类信息【Class对象】，静态变量，字符串常量等)。但是已经被最新的 JVM 取消了。现在，被加载的类作为元数据加载到底层操作系统的本地内存区。

### 2. 垃圾回收机制

> **GC的主要任务**
>
> * 分配内存
> * 确保被引用对象的内存不被错误的回收
> * 回收不再被引用的对象的内存空间
>
> ---
>
> **垃圾回收机制的主要解决问题**
>
> 

### 3. 什么情况下会发生栈内存溢出。

> * 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 **StackOverflowError** 异常。
> *  如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 **OutOfMemoryError** 异常。
>
> [Java 内存区域与内存溢出](https://wiki.jikexueyuan.com/project/java-vm/storage.html)

### 2. JVM 的内存结构，Eden 和 Survivor 比例。

> Eden区是一块，Survivor区是两块。
>
> Eden区和Survivor区的比例是8：1：1
>
> **JVM内存的结构为**
>
> * **堆**：存放对象
> * **栈**：运行时存放栈帧
> * **程序计数器**
> * **方法区**：存放类和常量
>
> 1.8之后取消了永久代，方法区概念上还是存在的，原先永久代中类的元信息会被放入本地内存，将类的静态变量和内部字符串放入到 java 堆中

### 3. JVM 中一次完整的 GC（垃圾回收） 流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数。

> 对象诞生即新生代（eden），在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记代数，如此检查一定次数后，晋升为老年代，